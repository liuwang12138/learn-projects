package com.gf.algorithm.class05;

/**
 * 不基于比较的排序
 *	1. 计数排序
 *	eg:	对员工的年龄进行排序
 *		<p>
 *			由于员工的年龄不会超过200岁，所以准备一个长度为201的数组arr
 *			遍历给的样本，如果年龄为1，则arr[1]++, 如果年龄为18，则arr[18]++
 *			最后输出，如果arr[1] == 5, 则输出5个1
 *					如果arr[18] == 3, 则输出3个18
 *		</p>
 *		桶排序的一种
 *		与数据的状况强相关
 *	2. 基数排序(非负的十进制数)
 *		算法思想：arr = [103, 24, 202, 46, 96, 10, 38, 9]
 *			a. 将数组中所有的数字按照最大值的位数补0
 *				arr = [103, 024, 202, 046, 096, 010, 038, 009]
 *			b. 准备10个桶	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 *			c. 将数组中的所有数字，按照个位数入桶(桶是队列结构，先进先出)
 *				[  0,   1,   2,   3,   4,   5,   6,   7,   8,   9]
 *				 010		202	103	 024		046		 038  009
 *			 	 								096
 *			d. 将桶中的数字按照桶的序号依次倒出(桶中的数字是先进先出的)
 *				[010, 202, 103, 024, 046, 096, 038, 009]
 *			e. 数组中的所有数字，按照十位数入桶
 *				[  0,   1,   2,   3,   4,   5,   6,   7,   8,   9]
 *				  202  010  024	 038  046					   096
 *				  103
 *				  009
 *			f. 出桶
 *				[202, 103, 009, 010, 024, 038, 046, 096]
 *			g. 数组中的数字按照百位数入桶，出桶
 *				[009, 010, 024, 038, 046, 096, 103, 202]
 *
 *		代码思想：arr = [101, 003, 202, 041, 302]
 *			a. 准备一个等长的help数组
 *			b. 遍历数组，按照个位数计数
 *						 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
 *				count = [0, 2, 2, 1, 0, 0, 0, 0, 0, 0]
 *			c. count'数组是累加和
 *				count'= [0, 2, 4, 5, 5, 5, 5, 5, 5, 5]
 *			d. 从右往左遍历arr, 首先碰到302, 看到个位数是2， 查询count'[2] = 4，则把302放到help[3]，count'[2]--
 *				> why?
 *				> 从我们原始算法中可以看到，302应该是最后一个进入2号桶的，也就是应该最后一个被倒出，所以应该放到所有012结尾的数字的最后面
 *			e. 从右往左依次遍历，重复d操作			
 *
 * 基于比较的排序，时间复杂度的极限是O(N*logN)
 * 
 */
public class C02_SortNotBasedOnCompare {
	
	public static void countSort(int[] arr) {
		// TODO: 计数排序
	}
	
	public static void radixSort(int[] arr) {
		// TODO: 基数排序
	}
	
	/**
	 * 在arr[left....right]上进行基数排序，其中最大值的位数是digit
	 */
	private static void radixSort(int[] arr, int left, int right, int digit) {
		// TODO: complete code
	}
}
